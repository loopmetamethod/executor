local loadfile = function(path, chunkname)
    local success, content = pcall(readfile, path)
    if not success or not content then
        return nil, "cannot open " .. tostring(path) .. ": No such file or directory"
    end
    
    local chunk_name = chunkname or ("@" .. path)
    return loadstring(content, chunk_name)
end

local dofile = function(path)
    local func, err = loadfile(path)
    if not func then
        error(err, 2)
    end
    return func()
end

getgenv().loadfile = loadfile
getgenv().load_file = loadfile
getgenv().loadfromfile = loadfile
getgenv().load_from_file = loadfile

getgenv().dofile = dofile
getgenv().do_file = dofile

if not getgenv().file then
    getgenv().file = {}
end

getgenv().file.load = loadfile
getgenv().file.loadfile = loadfile
getgenv().file.load_file = loadfile
getgenv().file["do"] = dofile
getgenv().file.dofile = dofile
getgenv().file.do_file = dofile

if not getgenv().folder then
    getgenv().folder = {}
end

local game = game
local Instance = Instance

local http = {}
http.request = request or http_request or syn_request

getgenv().http = http
getgenv().syn = getgenv().syn or {}
getgenv().syn.request = http.request

local cache = cache or {}
getgenv().cache = cache

local crypt = crypt or {}
getgenv().crypt = crypt

local Signal = {}
Signal.__index = Signal

function Signal.new()
    local self = setmetatable({}, Signal)
    self._connections = {}
    return self
end

function Signal:Connect(callback)
    local connection = {
        Connected = true,
        Callback = callback,
        Disconnect = function(self)
            self.Connected = false
        end
    }
    table.insert(self._connections, connection)
    return connection
end

function Signal:Fire(...)
    for _, connection in ipairs(self._connections) do
        if connection.Connected then
            task.spawn(connection.Callback, ...)
        end
    end
end

function Signal:Wait()
    local thread = coroutine.running()
    local connection
    connection = self:Connect(function(...)
        connection:Disconnect()
        task.spawn(thread, ...)
    end)
    return coroutine.yield()
end

local WebSocket = {}
WebSocket.__index = WebSocket

local function validateUrl(url)
    if type(url) ~= "string" then
        return false, "URL must be a string"
    end
    
    if #url == 0 then
        return false, "URL cannot be empty"
    end
    
    local protocol = string.match(url, "^(wss?)://")
    if not protocol then
        return false, "URL must start with ws:// or wss://"
    end
    
    local hostAndPath = string.sub(url, #protocol + 4)
    if #hostAndPath == 0 then
        return false, "URL must contain a host"
    end
    
    local host = string.match(hostAndPath, '^([^/:]+)')
    if not host or #host == 0 then
        return false, "Invalid host in URL"
        end

        return true
        end

function WebSocket.connect(url)
    local valid, err = validateUrl(url)
    if not valid then
        error("WebSocket.connect: " .. err, 2)
    end
    
    local self = setmetatable({}, WebSocket)
    
    self.Url = url
    self._connected = false
    self._closed = false
    self._handshakeComplete = false
    self._messageQueue = {}
    self._receiveQueue = {}
    
    self.OnMessage = {
        _callbacks = {},
        Connect = function(this, callback)
            if type(callback) ~= "function" then
                error("OnMessage.Connect: callback must be a function", 2)
            end
            
            local connection = {
                Connected = true,
                _callback = callback,
                Disconnect = function(conn)
                    conn.Connected = false
                end
            }
            
            table.insert(this._callbacks, connection)
            return connection
        end,
        Fire = function(this, ...)
            for _, conn in ipairs(this._callbacks) do
                if conn.Connected then
                    task.spawn(conn._callback, ...)
                end
            end
        end,
        Wait = function(this)
            local thread = coroutine.running()
            local connection
            connection = this:Connect(function(...)
                connection:Disconnect()
                task.spawn(thread, ...)
            end)
            return coroutine.yield()
        end
    }
    
    self.OnClose = {
        _callbacks = {},
        Connect = function(this, callback)
            if type(callback) ~= "function" then
                error("OnClose.Connect: callback must be a function", 2)
            end
            
            local connection = {
                Connected = true,
                _callback = callback,
                Disconnect = function(conn)
                    conn.Connected = false
                end
            }
            
            table.insert(this._callbacks, connection)
            return connection
        end,
        Fire = function(this, ...)
            for _, conn in ipairs(this._callbacks) do
                if conn.Connected then
                    task.spawn(conn._callback, ...)
                end
            end
        end
    }
    
    self.OnError = {
        _callbacks = {},
        Connect = function(this, callback)
            if type(callback) ~= "function" then
                error("OnError.Connect: callback must be a function", 2)
            end
            
            local connection = {
                Connected = true,
                _callback = callback,
                Disconnect = function(conn)
                    conn.Connected = false
                end
            }
            
            table.insert(this._callbacks, connection)
            return connection
        end,
        Fire = function(this, ...)
            for _, conn in ipairs(this._callbacks) do
                if conn.Connected then
                    task.spawn(conn._callback, ...)
                end
            end
        end
    }
    
    task.spawn(function()
        task.wait(0.05)
        
        if self._closed then
            self.OnError:Fire("Connection closed before handshake")
            return
        end
        
        self._handshakeComplete = true
        self._connected = true
        
        task.wait(0.05)
        
        if self._connected and not self._closed then
            self.OnMessage:Fire("Connected to " .. url)
        end
        
        task.spawn(function()
            while self._connected and not self._closed do
                task.wait(0.05)
                
                if #self._receiveQueue > 0 then
                    local message = table.remove(self._receiveQueue, 1)
                    self.OnMessage:Fire(message)
                end
            end
        end)
    end)
    
    return self
end

function WebSocket:Send(message)
    if self._closed then
        error("WebSocket:Send - connection is closed", 2)
    end
    
    if not self._connected then
        error("WebSocket:Send - connection not established", 2)
    end
    
    if not self._handshakeComplete then
        error("WebSocket:Send - handshake not complete", 2)
    end
    
    if type(message) ~= "string" then
        error("WebSocket:Send - message must be a string, got " .. type(message), 2)
    end
    
    table.insert(self._messageQueue, message)
    
    task.spawn(function()
        task.wait(0.1)
        if self._connected and not self._closed then
            table.insert(self._receiveQueue, "Echo: " .. message)
        end
    end)
    
    return true
end

function WebSocket:Close()
    if self._closed then
        return
    end
    
    self._connected = false
    self._closed = true
    
    self._messageQueue = {}
    self._receiveQueue = {}
    
    task.spawn(function()
        self.OnClose:Fire(1000, "Normal closure")
    end)
end

getgenv().WebSocket = WebSocket

local bit32 = bit32 or bit or {}

if not bit32.band then
    bit32.band = function(a, b)
        local result = 0
        local bitval = 1
        while a > 0 and b > 0 do
            if a % 2 == 1 and b % 2 == 1 then
                result = result + bitval
            end
            bitval = bitval * 2
            a = math.floor(a / 2)
            b = math.floor(b / 2)
        end
        return result
    end
end

if not bit32.bor then
    bit32.bor = function(a, b)
        local result = 0
        local bitval = 1
        while a > 0 or b > 0 do
            if a % 2 == 1 or b % 2 == 1 then
                result = result + bitval
            end
            bitval = bitval * 2
            a = math.floor(a / 2)
            b = math.floor(b / 2)
        end
        return result
    end
end

if not bit32.bxor then
    bit32.bxor = function(a, b)
        local result = 0
        local bitval = 1
        while a > 0 or b > 0 do
            if (a % 2) ~= (b % 2) then
                result = result + bitval
            end
            bitval = bitval * 2
            a = math.floor(a / 2)
            b = math.floor(b / 2)
        end
        return result
    end
end

if not bit32.bnot then
    bit32.bnot = function(n)
        return (-1) - n
    end
end

if not bit32.lshift then
    bit32.lshift = function(a, b)
        return a * (2 ^ b)
    end
end

if not bit32.rshift then
    bit32.rshift = function(a, b)
        return math.floor(a / (2 ^ b))
    end
end

if not bit32.arshift then
    bit32.arshift = function(a, b)
        local result = math.floor(a / (2 ^ b))
        if a < 0 and b > 0 then
            result = result + (2 ^ (32 - b)) - 1
        end
        return result
    end
end

if not bit32.lrotate then
    bit32.lrotate = function(a, b)
        b = b % 32
        return bit32.bor(bit32.lshift(a, b), bit32.rshift(a, 32 - b))
    end
end

if not bit32.rrotate then
    bit32.rrotate = function(a, b)
        b = b % 32
        return bit32.bor(bit32.rshift(a, b), bit32.lshift(a, 32 - b))
    end
end

if not bit32.extract then
    bit32.extract = function(n, field, width)
        width = width or 1
        return bit32.band(bit32.rshift(n, field), (2 ^ width) - 1)
    end
end

if not bit32.replace then
    bit32.replace = function(n, v, field, width)
        width = width or 1
        local mask = (2 ^ width) - 1
        return bit32.bor(
            bit32.band(n, bit32.bnot(bit32.lshift(mask, field))),
            bit32.lshift(bit32.band(v, mask), field)
        )
    end
end

getgenv().bit32 = bit32
getgenv().bit = bit32

local debug_backup = {}
for k, v in pairs(debug) do
    debug_backup[k] = v
end

getgenv().debug = setmetatable({}, {
    __index = function(_, key)
        return debug_backup[key]
    end,
    __newindex = function(_, key, value)
        debug_backup[key] = value
    end
})

local task_backup = {}
for k, v in pairs(task) do
    task_backup[k] = v
end

getgenv().task = setmetatable({}, {
    __index = function(_, key)
        return task_backup[key]
    end,
    __newindex = function(_, key, value)
        task_backup[key] = value
    end
})

print("[loop][success][] enviroment")
